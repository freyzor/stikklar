// create by Freyr Magnusson
// 2014-04-19
// derived from autogenerated code from NUKE/PyPose

// Included Arduino libraries
#include <Wire.h>

// 3d party Arduino libraries
#include <FiniteStateMachine.h>

// Arbotix libraries
#include <ax12.h>
#include <BioloidController.h>
#include <Commander.h>

// freybotlib
#include <vmath.h>

// stikklar
#include "gait_engine.h"
#include "wheel_engine.h"
#include "turret_engine.h"
#include "poses.h"
#include "blackboard.h"
#include "sensors.h"


Commander command;
BioloidController bioloidController;
WheelEngine wheelEngine;
GaitEngine gaitEngine;
TurretEngine turretEngine;

State DrivingState = State(enterDriving, updateDriving, noop);
State WalkingState = State(enterWalking, updateWalking, noop);
State GotoWalkingState = State(enterGotoWalkingState, updateGotoWalkingState, noop);
State GotoDrivingState = State(enterGotoDrivingState, updateGotoDrivingState, noop);

FSM fsm = FSM(WalkingState);

void setupWalkMode() {
    // setup the bioloid dynamixel config 
    gaitEngine.setupContoller();
    // extend the setup with the turret controllers
    turretEngine.setupContoller();
    // initialize the current servo positions
    bioloidController.readPose();
}

void setupWheelMode() {
    // need to setup the controller every time we enter the driving mode
    wheelEngine.setupContoller();
    // extend the setup with the turret controllers
    turretEngine.setupContoller();
    // initialize the current servo positions
    bioloidController.readPose();
}

void updateGaitEngine() {
    // if our previous interpolation is complete, recompute the IK
    if(bioloidController.interpolating == 0) {
        gaitEngine.update();
        turretEngine.updateServos();
        bioloidController.interpolateSetup(65);
    }

    // update joints
    bioloidController.interpolateStep();
}

void updateWheelEngine() {
    // if our previous interpolation is complete, recompute the IK
    if(bioloidController.interpolating == 0) {
        wheelEngine.update();
        turretEngine.updateServos();
        bioloidController.interpolateSetup(65);
    }

    // update joints
    bioloidController.interpolateStep();
}

void noop() {}

// ************ Driving Mode *************
void enterDriving() {
    debug_msg("enter Driving State");
    setupWheelMode();
}

void updateDriving() {
    updateWheelEngine();
}

// ********** Walking Mode **************
void enterWalking() {
    debug_msg("enter Walking State");
    setupWalkMode();
    gaitEngine.gaitSelect(RIPPLE_GEO);
}

void updateWalking() {
    updateGaitEngine();
}

void exitWalking() {
    debug_msg("exit Driving State");
}

// ******* Goto Driving transision state **********
void enterGotoDrivingState() {
    debug_msg("enter Goto Driving State");
    // we pick the point right under the coxa axle, 3sec should give two walk cycles
    gaitEngine.setStepToTarget(30, 30, DEFAULT_ENDPOINT_Z, 4000);
    gaitEngine.gaitSelect(RIPPLE_STEP_TO);
    debug_msg("driving goto set");
}

void updateGotoDrivingState() {
    if ( !gaitEngine.isContiouslySteppingTo() ) {
        // TODO: cache the gaits so we can reset them when standing up
        debug_msg("Done stepping into drive position");
        gaitEngine.cacheGaits();
        gaitEngine.doPose(WHEEL_MODE_MIDDLE, 2000);
        debug_msg("Driving stance achieved");
        fsm.transitionTo(DrivingState);
    } else {
        updateGaitEngine();
    }
}

// ******* Goto Driving transision state **********
void enterGotoWalkingState() {
    debug_msg("enter Goto Walking State");
    setupWalkMode();
    // enter an intermediate pose
    // TODO: we could run a sequence to orchestrate this better
    gaitEngine.doPose(WHEEL_CRAB_MIDDLE, 2000);
    debug_msg("Driving crab stance achieved");
    // TODO: set gaits to the cached version so we can resume from a sane pose
    gaitEngine.restoreCachedGaits();
    // go to the default walking stance, 3sec should give two walk cycles
    gaitEngine.setStepToTarget(DEFAULT_ENDPOINT_X, DEFAULT_ENDPOINT_Y, DEFAULT_ENDPOINT_Z, 4000);
    gaitEngine.gaitSelect(RIPPLE_STEP_TO);
    debug_msg("Walking goto set");
}

void updateGotoWalkingState() {
    if ( !gaitEngine.isContiouslySteppingTo() ) {
        debug_msg("Done stepping into default position");
        fsm.transitionTo(WalkingState);
    } else {
        updateGaitEngine();
    }
}

// The Commander protocol has values of -100 to 100, x/y/z speed are in mm/s
// To go faster than 100mm/s, we can use this speedMultiplier
int speedMultiplier;

void setup() {
    // set user LED as output
    pinMode(0, OUTPUT);

    // configure bioloid controller and engines
    // the controller is set to hold all the servos
    // individual engines will then limit and set up the active set of servos needed
    bioloidController.setup(AX_SERVO_COUNT);
    gaitEngine.setBioloidController(&bioloidController);
    wheelEngine.setBioloidController(&bioloidController);
    turretEngine.setBioloidController(&bioloidController);

    // initialize the bioloid dynamixel bus communicationss
    ax12Init(1000000l);

    delay(2000);

    // setup serial for usage with the Commander
    command.begin(38400);
  
    // wait, then check the voltage (LiPO safety)
    delay (1000);

    float voltage = (ax12GetRegister (AX_SENSOR, AX_PRESENT_VOLTAGE, 1)) / 10.0;
    Serial.println ("== Stikklar Mk3 ==");
    Serial.print ("System Voltage: ");
    Serial.print (voltage);
    Serial.println (" volts.");
    if (voltage < 10.0){
        Serial.println ("WARNING: voltage to low entering eternal sleep!");
        PlayTone(AX_SENSOR, 7);
        delay(500);
        PlayTone(AX_SENSOR, 3);
        while(1);
    }

    PlayTone(AX_SENSOR, 30);

    setupWalkMode();
    turretEngine.updateServos();
    gaitEngine.setupIK();
    gaitEngine.gaitSelect(RIPPLE_GEO);
    gaitEngine.readPose();
    gaitEngine.slowStart(2000);

    speedMultiplier = 1;
}

void setBodyRotation(Commander &command){
    gaitEngine.bodyRot.y = (((float)command.lookV))/250.0;
    if((command.buttons&BUT_RT) > 0) {
        gaitEngine.bodyRot.x = ((float)command.lookH)/250.0;
        gaitEngine.bodyRot.z = 0.0;
    } else {
        gaitEngine.bodyRot.z = ((float)command.lookH)/250.0;
        gaitEngine.bodyRot.x = 0.0;
    }
}

void setCenterOfGravityOffset(Commander &command){
    // we invert the joystick values since we ned to shift the legs in the opposite direction to move the body correctly
    // can move upto move 125mm in each direction
    if((command.buttons&BUT_RT) == 0) {
        // move on the XY ground plane
        // gaitEngine.centerOfGravityOffset.x = -(int)command.lookV;
        gaitEngine.bodyPos.x = -(int)command.lookV;
        // gaitEngine.centerOfGravityOffset.y = -(int)command.lookH;
        gaitEngine.bodyPos.y = -(int)command.lookH;
        gaitEngine.centerOfGravityOffset.z = 0;
    } else {
        // move up or down
        gaitEngine.centerOfGravityOffset.x = 0;
        gaitEngine.centerOfGravityOffset.y = 0;
        gaitEngine.centerOfGravityOffset.z = (int)command.lookV;
    }
}

void setWalkMovement(Commander &command){
    gaitEngine.Xspeed = int(speedMultiplier*command.walkV);
    if((command.buttons&BUT_LT) > 0){
        gaitEngine.Yspeed = int(speedMultiplier*command.walkH);
        gaitEngine.Rspeed = 0.0;
    } else {
        gaitEngine.Yspeed = 0;
        gaitEngine.Rspeed = -float(speedMultiplier*command.walkH)/250.0;
    }
}

void setGaitMode(Commander &command) {
    if(command.buttons&BUT_R1) { 
        gaitEngine.gaitSelect( RIPPLE_SMOOTH );
        speedMultiplier=1;

    } else if(command.buttons&BUT_R2) {
        gaitEngine.gaitSelect( RIPPLE );
        speedMultiplier=1;

    } else if(command.buttons&BUT_R3) {
        gaitEngine.gaitSelect( RIPPLE_GEO );
        speedMultiplier=1;

    } else if(command.buttons&BUT_L4) { 
        gaitEngine.gaitSelect( AMBLE_SMOOTH );
        speedMultiplier=2;

    } else if(command.buttons&BUT_L5) {
        gaitEngine.gaitSelect( AMBLE );
        speedMultiplier=2;
    }
}

void setWheelMovement(Commander &command) {
    // max 1024 => speed 125*8 => 500
    wheelEngine.speed = command.walkV * 8;
    // max steer angle => 154, 125
    wheelEngine.steering = int((command.walkH * 0.88) + 0.5);
}

void setTurretMovement(Commander &command) {
    // pan (-150, 150) degrees
    turretEngine.pan = int((command.lookH * 1.2) + 0.5);
    // tilt (-90, 90) degrees
    turretEngine.tilt = int((command.lookV * 0.72) + 0.5);
}

void processCommands() {
    // take commands
    if(command.ReadMsgs() == 0)
        return;
    // toggle LED
    digitalWrite(0,HIGH-digitalRead(0));

    // set speeds
    if ( fsm.isInState(WalkingState) ) {
        if (command.buttons & BUT_L6) {
            // goto driving mode
            fsm.transitionTo(GotoDrivingState);
        } else {
            setGaitMode(command);
            setWalkMovement(command);
            //setCenterOfGravityOffset(command);
            //setBodyRotation(command);
            setTurretMovement(command);
        }
    } else if ( fsm.isInState(DrivingState) ) {
        if (command.buttons & BUT_L6) {
            // goto walk mode
            fsm.transitionTo(GotoWalkingState);
        } else {
            setWheelMovement(command);
            setTurretMovement(command);
        }
    }
}


long lastSensorTime = 0;
void processSensors(){
  // TODO: MiniIMU 9 DOF orientation
    if ((millis() - lastSensorTime) < 2000) return;

    logval("IR Top", ax12GetRegister(AX_SENSOR, AX_RIGHT_IR_DATA, 1));
    logval("IR Front", ax12GetRegister(AX_SENSOR, AX_CENTER_IR_DATA, 1));
    logval("IR Bottom", ax12GetRegister(AX_SENSOR, AX_LEFT_IR_DATA, 1));
    // logval("Lum Top", ax12GetRegister(AX_SENSOR, AX_RIGHT_LUMINOSITY, 1));
    // logval("Lum Front", ax12GetRegister(AX_SENSOR, AX_CENTER_LUMINOSITY, 1));
    // logval("Lum Bottom", ax12GetRegister(AX_SENSOR, AX_LEFT_LUMINOSITY, 1));

    //PlayTone(AX_SENSOR, 40);


    lastSensorTime = millis();
}

void loop(){
    monitorDynamixel();
    processCommands();
    //processSensors();

    fsm.update();
    turretEngine.updateServos();
}

int ax12Ping(int id){
    setTX(id);
    // 0xFF 0xFF ID LENGTH INSTRUCTION PARAM... CHECKSUM    
    int checksum = ~((id + 0x02 + AX_PING) % 256);
    ax12writeB(0xFF);
    ax12writeB(0xFF);
    ax12writeB(byte(id));
    ax12writeB(0x02);    // length
    ax12writeB(AX_PING);
    ax12writeB(checksum);  
    setRX(id);    
    if(ax12ReadPacket(6) > 0){
        // return the error
        return ax_rx_buffer[4];
    }else{
        return -1;
    }
}

long lastMonitorTime = 0;

void monitorDynamixel() {
    if ((millis() - lastMonitorTime) < 5000) return;
    int error;
    for(int id=1; id <= 16; id++) {
        error = ax12Ping(id);
        if (error > 0) writeErrors(id, error);
    }
    
    lastMonitorTime = millis();
}

void writeErrors(int id, int error) {
    log("Error id="); log(id); 
// ERR_VOLTAGE                 1
    if (error&ERR_VOLTAGE) log(" voltage");
// ERR_ANGLE_LIMIT             2
    if (error&ERR_ANGLE_LIMIT) log(" angle");
// ERR_OVERHEATING             4
    if (error&ERR_OVERHEATING) log(" heat");
// ERR_RANGE                   8
    if (error&ERR_RANGE) log(" range");
// ERR_CHECKSUM                16
    if (error&ERR_CHECKSUM) log(" checksum");
// ERR_OVERLOAD                32
    if (error&ERR_OVERLOAD) log(" overload");
// ERR_INSTRUCTION             64
    if (error&ERR_INSTRUCTION) log(" instruction");

    logln("");

    PlayTone(AX_SENSOR, 13);
}

// #define LED_RED 0x01
// #define LED_GREEN 0x02
// #define LED_BLUE 0x04

// void setLEDs() {
//     for(int id=1; id <= 16; id++) {
//         if (id % 2 == 0) {
//             ax12SetRegister(id, AX_LED, LED_BLUE);
//         } else {
//             ax12SetRegister(id, AX_LED, LED_RED);
//         }
//     } 
// }